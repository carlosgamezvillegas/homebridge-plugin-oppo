"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MDNSServer = exports.SendResultFormatError = exports.SendResultFailedRatio = void 0;
const assert_1 = __importDefault(require("assert"));
const debug_1 = __importDefault(require("debug"));
const dgram_1 = __importDefault(require("dgram"));
const DNSPacket_1 = require("./coder/DNSPacket");
const NetworkManager_1 = require("./NetworkManager");
const domain_formatter_1 = require("./util/domain-formatter");
const errors_1 = require("./util/errors");
const debug = debug_1.default("ciao:MDNSServer");
/**
 * Returns the ration of rejected SendResults in the array.
 * A ratio of 0 indicates all sends were successful.
 * A ration of 1 indicates all sends failed.
 * A number in between signals that some of the sends failed.
 *
 * @param results - Array of {@link SendResult}
 */
function SendResultFailedRatio(results) {
    if (results.length === 0) {
        return 0;
    }
    let failedCount = 0;
    for (const result of results) {
        if (result.status === "rejected") {
            failedCount++;
        }
    }
    return failedCount / results.length;
}
exports.SendResultFailedRatio = SendResultFailedRatio;
function SendResultFormatError(results, prefix, includeStack = false) {
    let failedCount = 0;
    for (const result of results) {
        if (result.status === "rejected") {
            failedCount++;
        }
    }
    if (!prefix) {
        prefix = "Failed to send packets";
    }
    if (failedCount < results.length) {
        prefix += ` (${failedCount}/${results.length}):`;
    }
    else {
        prefix += ":";
    }
    if (includeStack) {
        let string = "=============================\n" + prefix;
        for (const result of results) {
            if (result.status === "rejected") {
                string += "\n--------------------\n" +
                    "Failed to send packet on interface " + result.interface + ": " + result.reason.stack;
            }
        }
        string += "\n=============================";
        return string;
    }
    else {
        let string = prefix;
        for (const result of results) {
            if (result.status === "rejected") {
                string += "\n- Failed to send packet on interface " + result.interface + ": " + result.reason.message;
            }
        }
        return string;
    }
}
exports.SendResultFormatError = SendResultFormatError;
/**
 * This class can be used to create a mdns server to send and receive mdns packets on the local network.
 *
 * Currently only udp4 sockets will be advertised.
 */
class MDNSServer {
    constructor(handler, options) {
        this.sockets = new Map();
        // RFC 6762 15.1. If we are not the first responder bound to 5353 we can't receive unicast responses
        // thus the QU flag must not be used in queries. Responders are only affected when sending probe queries.
        // Probe queries should be sent with QU set, though can't be sent with QU when we can't receive unicast responses.
        this.suppressUnicastResponseFlag = false;
        this.bound = false;
        this.closed = false;
        assert_1.default(handler, "handler cannot be undefined");
        this.handler = handler;
        this.networkManager = new NetworkManager_1.NetworkManager({
            interface: options && options.interface,
            excludeIpv6Only: true,
        });
        this.networkManager.on("network-update" /* NETWORK_UPDATE */, this.handleUpdatedNetworkInterfaces.bind(this));
    }
    getNetworkManager() {
        return this.networkManager;
    }
    getBoundInterfaceNames() {
        return this.sockets.keys();
    }
    async bind() {
        if (this.closed) {
            throw new Error("Cannot rebind closed server!");
        }
        // RFC 6762 15.1. suggest that we probe if we are not the only socket.
        // though as ciao will probably always be installed besides an existing mdns responder, we just assume that without probing
        // As it only affects probe queries, impact isn't that big.
        this.suppressUnicastResponseFlag = true;
        // wait for the first network interfaces to be discovered
        await this.networkManager.waitForInit();
        const promises = [];
        for (const name of this.networkManager.getInterfaceMap().keys()) {
            const socket = this.createDgramSocket(name, true);
            const promise = this.bindSocket(socket, name, "IPv4" /* IPv4 */)
                .then(() => {
                this.sockets.set(name, socket);
            }, reason => {
                // TODO if bind errors we probably will never bind again
                console.log("Could not bind detected network interface: " + reason.stack);
            });
            promises.push(promise);
        }
        return Promise.all(promises).then(() => {
            this.bound = true;
            // map void[] to void
        });
    }
    shutdown() {
        this.networkManager.shutdown();
        for (const socket of this.sockets.values()) {
            socket.close();
        }
        this.bound = false;
        this.closed = true;
        this.sockets.clear();
    }
    sendQueryBroadcast(query) {
        const packets = DNSPacket_1.DNSPacket.createDNSQueryPackets(query);
        if (packets.length > 1) {
            debug("Query broadcast is split into %d packets!", packets.length);
        }
        const promises = [];
        for (const packet of packets) {
            promises.push(this.sendOnAllNetworks(packet));
        }
        return Promise.all(promises).then((values) => {
            const results = [];
            for (const value of values) { // replace with .flat method when we have node >= 11.0.0 requirement
                results.concat(value);
            }
            return results;
        });
    }
    sendResponseBroadcast(response) {
        const packet = DNSPacket_1.DNSPacket.createDNSResponsePacketsFromRRSet(response);
        return this.sendOnAllNetworks(packet);
    }
    sendResponse(response, endpointOrInterface, callback) {
        this.send(response, endpointOrInterface).then(result => {
            if (result.status === "rejected") {
                if (callback) {
                    callback(new Error("Encountered socket error on " + result.reason.name + ": " + result.reason.message));
                }
                else {
                    MDNSServer.logSocketError(result.interface, result.reason);
                }
            }
            else if (callback) {
                callback();
            }
        });
    }
    sendOnAllNetworks(packet) {
        this.checkUnicastResponseFlag(packet);
        const message = packet.encode();
        this.assertBeforeSend(message, "IPv4" /* IPv4 */);
        const promises = [];
        for (const [name, socket] of this.sockets) {
            const promise = new Promise(resolve => {
                socket.send(message, MDNSServer.MDNS_PORT, MDNSServer.MULTICAST_IPV4, error => {
                    if (error && !MDNSServer.isSilencedSocketError(error)) {
                        resolve({
                            status: "rejected",
                            interface: name,
                            reason: error,
                        });
                    }
                    else {
                        resolve({
                            status: "fulfilled",
                            interface: name,
                            value: undefined,
                        });
                    }
                });
            });
            promises.push(promise);
        }
        return Promise.all(promises);
    }
    send(packet, endpointOrInterface) {
        this.checkUnicastResponseFlag(packet);
        const message = packet.encode();
        this.assertBeforeSend(message, "IPv4" /* IPv4 */);
        let address;
        let port;
        let name;
        if (typeof endpointOrInterface === "string") { // its a network interface name
            address = MDNSServer.MULTICAST_IPV4;
            port = MDNSServer.MDNS_PORT;
            name = endpointOrInterface;
        }
        else {
            address = endpointOrInterface.address;
            port = endpointOrInterface.port;
            name = endpointOrInterface.interface;
        }
        const socket = this.sockets.get(name);
        if (!socket) {
            throw new errors_1.InterfaceNotFoundError(`Could not find socket for given network interface '${name}'`);
        }
        return new Promise(resolve => {
            socket.send(message, port, address, error => {
                if (error && !MDNSServer.isSilencedSocketError(error)) {
                    resolve({
                        status: "rejected",
                        interface: name,
                        reason: error,
                    });
                }
                else {
                    resolve({
                        status: "fulfilled",
                        interface: name,
                        value: undefined,
                    });
                }
            });
        });
    }
    checkUnicastResponseFlag(packet) {
        if (this.suppressUnicastResponseFlag && packet.type === 0 /* QUERY */) {
            packet.questions.forEach(record => record.unicastResponseFlag = false);
        }
    }
    assertBeforeSend(message, family) {
        if (this.closed) {
            throw new errors_1.ServerClosedError("Cannot send packets on a closed mdns server!");
        }
        assert_1.default(this.bound, "Cannot send packets before server is not bound!");
        const ipHeaderSize = family === "IPv4" /* IPv4 */ ? MDNSServer.DEFAULT_IP4_HEADER : MDNSServer.DEFAULT_IP6_HEADER;
        // RFC 6762 17.
        assert_1.default(ipHeaderSize + MDNSServer.UDP_HEADER + message.length <= 9000, "DNS cannot exceed the size of 9000 bytes even with IP Fragmentation!");
    }
    createDgramSocket(name, reuseAddr = false, type = "udp4") {
        const socket = dgram_1.default.createSocket({
            type: type,
            reuseAddr: reuseAddr,
        });
        socket.on("message", this.handleMessage.bind(this, name));
        socket.on("error", error => {
            if (!MDNSServer.isSilencedSocketError(error)) {
                MDNSServer.logSocketError(name, error);
            }
        });
        return socket;
    }
    bindSocket(socket, name, family) {
        const networkInterface = this.networkManager.getInterface(name);
        if (!networkInterface) {
            throw new errors_1.InterfaceNotFoundError(`Could not find network interface '${name}' in network manager which socket is going to be bind to!`);
        }
        return new Promise((resolve, reject) => {
            const errorHandler = (error) => reject(new Error("Failed to bind on interface " + name + ": " + error.message));
            socket.once("error", errorHandler);
            socket.bind(MDNSServer.MDNS_PORT, () => {
                socket.setRecvBufferSize(800 * 1024); // setting max recv buffer size to 800KiB (Pi will max out at 352KiB)
                socket.removeListener("error", errorHandler);
                const multicastAddress = family === "IPv4" /* IPv4 */ ? MDNSServer.MULTICAST_IPV4 : MDNSServer.MULTICAST_IPV6;
                const interfaceAddress = family === "IPv4" /* IPv4 */ ? networkInterface.ipv4 : networkInterface.ipv6;
                assert_1.default(interfaceAddress, "Interface address for " + name + " cannot be undefined!");
                try {
                    socket.addMembership(multicastAddress, interfaceAddress);
                    socket.setMulticastInterface(interfaceAddress);
                    socket.setMulticastTTL(MDNSServer.MDNS_TTL); // outgoing multicast datagrams
                    socket.setTTL(MDNSServer.MDNS_TTL); // outgoing unicast datagrams
                    socket.setMulticastLoopback(true);
                    resolve();
                }
                catch (error) {
                    try {
                        socket.close();
                    }
                    catch (error) {
                        debug("Error while closing socket which failed to bind. Error may be expected: " + error.message);
                    }
                    reject(new Error("Error binding socket on " + name + ": " + error.stack));
                }
            });
        });
    }
    handleMessage(name, buffer, rinfo) {
        if (!this.bound) {
            return;
        }
        const networkInterface = this.networkManager.getInterface(name);
        if (!networkInterface) {
            debug("Received packet on non existing network interface: %s!", name);
            return;
        }
        const ip4Netaddress = domain_formatter_1.getNetAddress(rinfo.address, networkInterface.ip4Netmask);
        if (ip4Netaddress !== networkInterface.ipv4Netaddress) {
            // This isn't a problem on macOS (it seems like to respect the desired interface we supply for our membership)
            // On Linux based system such filtering seems to not happen :thinking: we just get any traffic and it's like
            // we are just bound to 0.0.0.0
            return;
        }
        let packet;
        try {
            packet = DNSPacket_1.DNSPacket.decode(buffer);
        }
        catch (error) {
            debug("Received a malformed packet from %o on interface %s. This might or might not be a problem. " +
                "Here is the received packet for debugging purposes '%s'. " +
                "Packet decoding failed with %s", rinfo, name, buffer.toString("base64"), error.stack);
            return;
        }
        if (packet.opcode !== 0 /* QUERY */) {
            // RFC 6762 18.3 we MUST ignore messages with opcodes other than zero (QUERY)
            return;
        }
        if (packet.rcode !== 0 /* NoError */) {
            // RFC 6762 18.3 we MUST ignore messages with response code other than zero (NoError)
            return;
        }
        const endpoint = {
            address: rinfo.address,
            port: rinfo.port,
            interface: name,
        };
        if (packet.type === 0 /* QUERY */) {
            try {
                this.handler.handleQuery(packet, endpoint);
            }
            catch (error) {
                console.warn("Error occurred handling incoming (on " + name + ") dns query packet: " + error.stack);
            }
        }
        else if (packet.type === 1 /* RESPONSE */) {
            if (rinfo.port !== MDNSServer.MDNS_PORT) {
                // RFC 6762 6.  Multicast DNS implementations MUST silently ignore any Multicast DNS responses
                //    they receive where the source UDP port is not 5353.
                return;
            }
            try {
                this.handler.handleResponse(packet, endpoint);
            }
            catch (error) {
                console.warn("Error occurred handling incoming (on " + name + ") dns response packet: " + error.stack);
            }
        }
    }
    static isSilencedSocketError(error) {
        // silence those errors
        // they happen when the host is not reachable (EADDRNOTAVAIL for 224.0.0.251 or EHOSTDOWN for any unicast traffic)
        // caused by yet undetected network changes.
        // as we listen to 0.0.0.0 and the socket stays valid, this is not a problem
        const silenced = error.message.includes("EADDRNOTAVAIL") || error.message.includes("EHOSTDOWN")
            || error.message.includes("ENETUNREACH") || error.message.includes("EHOSTUNREACH");
        if (silenced) {
            debug("Silenced and ignored error (This is/should not be a problem, this message is only for informational purposes): " + error.message);
        }
        return silenced;
    }
    static logSocketError(name, error) {
        console.warn(`Encountered MDNS socket error on socket '${name}' : ${error.stack}`);
        return;
    }
    handleUpdatedNetworkInterfaces(networkUpdate) {
        if (networkUpdate.removed) {
            for (const networkInterface of networkUpdate.removed) {
                const socket = this.sockets.get(networkInterface.name);
                this.sockets.delete(networkInterface.name);
                if (socket) {
                    socket.close();
                }
            }
        }
        if (networkUpdate.changes) {
            for (const change of networkUpdate.changes) {
                const socket = this.sockets.get(change.name);
                assert_1.default(socket, "Couldn't find socket for network change!");
                if (!change.outdatedIpv4 && change.updatedIpv4) {
                    // this does currently not happen, as we exclude ipv6 only interfaces
                    // thus such a change would be happening through the ADDED array
                    assert_1.default.fail("Reached illegal state! IPv4 address changed from undefined to defined!");
                }
                else if (change.outdatedIpv4 && !change.updatedIpv4) {
                    // this does currently not happen, as we exclude ipv6 only interfaces
                    // thus such a change would be happening through the REMOVED array
                    assert_1.default.fail("Reached illegal state! IPV4 address change from defined to undefined!");
                }
                else if (change.outdatedIpv4 && change.updatedIpv4) {
                    try {
                        socket.dropMembership(MDNSServer.MULTICAST_IPV4, change.outdatedIpv4);
                    }
                    catch (error) {
                        debug("Thrown expected error when dropping outdated address membership: " + error.message);
                    }
                    try {
                        socket.addMembership(MDNSServer.MULTICAST_IPV4, change.updatedIpv4);
                    }
                    catch (error) {
                        debug("Thrown expected error when adding new address membership: " + error.message);
                    }
                    socket.setMulticastInterface(change.updatedIpv4);
                }
            }
        }
        if (networkUpdate.added) {
            for (const networkInterface of networkUpdate.added) {
                const socket = this.createDgramSocket(networkInterface.name, true);
                this.bindSocket(socket, networkInterface.name, "IPv4" /* IPv4 */).then(() => {
                    this.sockets.set(networkInterface.name, socket);
                }, reason => {
                    // TODO if bind errors we probably will never bind again
                    console.log("Could not bind detected network interface: " + reason.stack);
                });
            }
        }
    }
}
exports.MDNSServer = MDNSServer;
MDNSServer.DEFAULT_IP4_HEADER = 20;
MDNSServer.DEFAULT_IP6_HEADER = 40;
MDNSServer.UDP_HEADER = 8;
MDNSServer.MDNS_PORT = 5353;
MDNSServer.MDNS_TTL = 255;
MDNSServer.MULTICAST_IPV4 = "224.0.0.251";
MDNSServer.MULTICAST_IPV6 = "FF02::FB";
//# sourceMappingURL=MDNSServer.js.map