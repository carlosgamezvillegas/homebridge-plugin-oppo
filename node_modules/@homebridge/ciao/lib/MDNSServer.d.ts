import { DNSPacket, DNSProbeQueryDefinition, DNSQueryDefinition, DNSResponseDefinition } from "./coder/DNSPacket";
import { InterfaceName, NetworkManager } from "./NetworkManager";
export interface EndpointInfo {
    address: string;
    port: number;
    interface: string;
}
export interface SendFulfilledResult<T> {
    status: "fulfilled";
    interface: InterfaceName;
    value: T;
}
export interface SendRejectedResult {
    status: "rejected";
    interface: InterfaceName;
    reason: Error;
}
export declare type SendResult<T> = SendFulfilledResult<T> | SendRejectedResult;
export declare type SendCallback = (error?: Error | null) => void;
/**
 * Returns the ration of rejected SendResults in the array.
 * A ratio of 0 indicates all sends were successful.
 * A ration of 1 indicates all sends failed.
 * A number in between signals that some of the sends failed.
 *
 * @param results - Array of {@link SendResult}
 */
export declare function SendResultFailedRatio<T>(results: SendResult<T>[]): number;
export declare function SendResultFormatError<T>(results: SendResult<T>[], prefix?: string, includeStack?: boolean): string;
/**
 * Defines the options passed to the underlying mdns server.
 */
export interface MDNSServerOptions {
    /**
     * If specified, the mdns server will only listen on the specified interfaces (allowlist).
     * It can be supplied as a string (representing a single interface) or as an array of strings
     * to define multiple interfaces.
     * The interface can be defined by specifying the interface name (like 'en0') or
     * by specifying an ip address.
     */
    interface?: string | string[];
}
export interface PacketHandler {
    handleQuery(packet: DNSPacket, rinfo: EndpointInfo): void;
    handleResponse(packet: DNSPacket, rinfo: EndpointInfo): void;
}
/**
 * This class can be used to create a mdns server to send and receive mdns packets on the local network.
 *
 * Currently only udp4 sockets will be advertised.
 */
export declare class MDNSServer {
    static readonly DEFAULT_IP4_HEADER = 20;
    static readonly DEFAULT_IP6_HEADER = 40;
    static readonly UDP_HEADER = 8;
    static readonly MDNS_PORT = 5353;
    static readonly MDNS_TTL = 255;
    static readonly MULTICAST_IPV4 = "224.0.0.251";
    static readonly MULTICAST_IPV6 = "FF02::FB";
    private readonly handler;
    private readonly networkManager;
    private readonly sockets;
    private suppressUnicastResponseFlag;
    private bound;
    private closed;
    constructor(handler: PacketHandler, options?: MDNSServerOptions);
    getNetworkManager(): NetworkManager;
    getBoundInterfaceNames(): IterableIterator<InterfaceName>;
    bind(): Promise<void>;
    shutdown(): void;
    sendQueryBroadcast(query: DNSQueryDefinition | DNSProbeQueryDefinition): Promise<SendResult<void>[]>;
    sendResponseBroadcast(response: DNSResponseDefinition): Promise<SendResult<void>[]>;
    sendResponse(response: DNSPacket, endpoint: EndpointInfo, callback?: SendCallback): void;
    sendResponse(response: DNSPacket, interfaceName: InterfaceName, callback?: SendCallback): void;
    private sendOnAllNetworks;
    send(packet: DNSPacket, endpointOrInterface: EndpointInfo | InterfaceName): Promise<SendResult<void>>;
    private checkUnicastResponseFlag;
    private assertBeforeSend;
    private createDgramSocket;
    private bindSocket;
    private handleMessage;
    private static isSilencedSocketError;
    private static logSocketError;
    private handleUpdatedNetworkInterfaces;
}
//# sourceMappingURL=MDNSServer.d.ts.map