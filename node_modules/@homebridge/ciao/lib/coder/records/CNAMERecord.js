"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CNAMERecord = void 0;
const assert_1 = __importDefault(require("assert"));
const ResourceRecord_1 = require("../ResourceRecord");
class CNAMERecord extends ResourceRecord_1.ResourceRecord {
    constructor(name, cname, flushFlag, ttl) {
        if (typeof name === "string") {
            super(name, 5 /* CNAME */, ttl, flushFlag);
        }
        else {
            assert_1.default(name.type === 5 /* CNAME */);
            super(name);
        }
        if (!cname.endsWith(".")) {
            cname += ".";
        }
        this.cname = cname;
    }
    getRDataEncodingLength(coder) {
        return coder.getNameLength(this.cname);
    }
    encodeRData(coder, buffer, offset) {
        const oldOffset = offset;
        const cnameLength = coder.encodeName(this.cname, offset);
        offset += cnameLength;
        return offset - oldOffset; // written bytes
    }
    static decodeData(coder, header, buffer, offset) {
        const oldOffset = offset;
        const decodedName = coder.decodeName(offset);
        offset += decodedName.readBytes;
        return {
            data: new CNAMERecord(header, decodedName.data),
            readBytes: offset - oldOffset,
        };
    }
    clone() {
        return new CNAMERecord(this.getRecordRepresentation(), this.cname);
    }
    dataAsString() {
        return this.cname;
    }
    dataEquals(record) {
        return this.cname === record.cname;
    }
}
exports.CNAMERecord = CNAMERecord;
//# sourceMappingURL=CNAMERecord.js.map