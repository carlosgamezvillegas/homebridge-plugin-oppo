"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PTRRecord = void 0;
const assert_1 = __importDefault(require("assert"));
const ResourceRecord_1 = require("../ResourceRecord");
class PTRRecord extends ResourceRecord_1.ResourceRecord {
    constructor(name, ptrName, flushFlag, ttl) {
        if (typeof name === "string") {
            super(name, 12 /* PTR */, ttl, flushFlag);
        }
        else {
            assert_1.default(name.type === 12 /* PTR */);
            super(name);
        }
        if (!ptrName.endsWith(".")) {
            ptrName += ".";
        }
        this.ptrName = ptrName;
    }
    getRDataEncodingLength(coder) {
        return coder.getNameLength(this.ptrName);
    }
    encodeRData(coder, buffer, offset) {
        const oldOffset = offset;
        const ptrNameLength = coder.encodeName(this.ptrName, offset);
        offset += ptrNameLength;
        return offset - oldOffset; // written bytes
    }
    static decodeData(coder, header, buffer, offset) {
        const oldOffset = offset;
        const decodedName = coder.decodeName(offset);
        offset += decodedName.readBytes;
        return {
            data: new PTRRecord(header, decodedName.data),
            readBytes: offset - oldOffset,
        };
    }
    clone() {
        return new PTRRecord(this.getRecordRepresentation(), this.ptrName);
    }
    dataAsString() {
        return this.ptrName;
    }
    dataEquals(record) {
        return this.ptrName === record.ptrName;
    }
}
exports.PTRRecord = PTRRecord;
//# sourceMappingURL=PTRRecord.js.map